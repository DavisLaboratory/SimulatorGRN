---
title: "Activation function characteristics"
output:
  html_notebook: 
    number_sections: yes
    toc: yes
    fig_caption: yes
---

Plots showing activation function behaviour of different biological interactions.


```{r, message=FALSE, warning=FALSE, include=FALSE}
source('../GraphGRN-methods.R')
source('../GraphGRN.R')
source('../SimulationGRN-methods.R')
source('../SimulationGRN.R')
source('analysis_methods.R')
library(igraph)
library(ggplot2)
library(plotly)
library(grid)
library(ggraph)
library(deSolve)
library(foreach)
library(nleqslv)
library(mclust)
library(shiny)

#activation function
fAct <- function(TF, EC50 = 0.5, n = 1.39) {
  B = (EC50 ^ n - 1) / (2 * EC50 ^ n - 1)
  K_n = (B - 1)
  act = B * TF ^ n / (K_n + TF ^ n)
  
  return(act)
}

#multiplot function
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
	
	# Make a list from the ... arguments and plotlist
	plots <- c(list(...), plotlist)
	
	numPlots = length(plots)
	
	# If layout is NULL, then use 'cols' to determine layout
	if (is.null(layout)) {
		# Make the panel
		# ncol: Number of columns of plots
		# nrow: Number of rows needed, calculated from # of cols
		layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
						 ncol = cols, nrow = ceiling(numPlots/cols))
	}
	
	if (numPlots==1) {
		print(plots[[1]])
		
	} else {
		# Set up the page
		grid.newpage()
		pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
		
		# Make each plot, in the correct location
		for (i in 1:numPlots) {
			# Get the i,j matrix positions of the regions that contain this subplot
			matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
			
			print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
											layout.pos.col = matchidx$col))
		}
	}
}

nsize = 40
```

#Activation functions
In the case where **A** activates or inhibits **B**, the rate equations are shown
below which are equal to the activation equations due to the parameter choices.

```{r, echo=FALSE, message=FALSE, warning=FALSE}
#activation function plots
f = function(A, rateeqn) {
  B = 0
  eval(parse(text = rateeqn))
}
A = seq(0, 1, length.out = 100)

#A->B
gact = new('GraphGRN')
gact = addNode(gact, 'A')
gact = addNode(gact, 'B')
gact = addEdge(gact, 'A', 'B', activation = T)
acteqn = generateRateEqn(getNode(gact, 'B'), gact)
B = f(A, acteqn)
plot(A, B, col = 3, type = 'l', main = 'A single activation function')

#A->B
ginb = new('GraphGRN')
ginb = addNode(ginb, 'A')
ginb = addNode(ginb, 'B')
ginb = addEdge(ginb, 'A', 'B', activation = F)
inbeqn = generateRateEqn(getNode(ginb, 'B'), ginb)
B = f(A, inbeqn)
par(new = T)
plot(A, B, col = 2, type = 'l')
par(new = F)
```


#OR based interactions with the SAME act/inhib effect
Interactions covered here are those where both the regulators have the same
activation behaviour, that is either both are activators or both are inhibitors.
Each regulator complements the other.

The case of independent OR inhibitions (right figures) looks more like the
scenario where **A and B** inhibit C with dependence.

```{r, echo=FALSE, message=FALSE, warning=FALSE}
igraph_options(plot.layout=layout_in_circle)
par(mfrow = c(1, 2))
colmap = c('TRUE' = 'green', 'FALSE' = 'red')

#2 activators
gact = new('GraphGRN')
for (n in LETTERS[1:3]) {
  gact = addNode(gact, n)
}
gact = addEdge(gact, 'A', 'C', activation = T)
gact = addEdge(gact, 'B', 'C', activation = T)

gdf = GraphGRN2df(gact)
ig = graph_from_data_frame(gdf$edges, directed = T, gdf$nodes)
E(ig)$color = colmap[as.character(E(ig)$type)]
plot(ig, vertex.size = nsize, main = '2 independent activators')

#2 inhibitors
ginb = new('GraphGRN')
for (n in LETTERS[1:3]) {
  ginb = addNode(ginb, n)
}
ginb = addEdge(ginb, 'A', 'C', activation = F)
ginb = addEdge(ginb, 'B', 'C', activation = F)

gdf = GraphGRN2df(ginb)
ig = graph_from_data_frame(gdf$edges, directed = T, gdf$nodes)
E(ig)$color = colmap[as.character(E(ig)$type)]
plot(ig, vertex.size = nsize, main = '2 independent inhibitors')

#activation function plots
f = function(A, B, rateeqn) {
  C = 0
  eval(parse(text = rateeqn))
}

acteqn = generateRateEqn(getNode(gact, 'C'), gact)
inbeqn = generateRateEqn(getNode(ginb, 'C'), ginb)

#plot activation functions
pdata = expand.grid('A' = seq(0, 1, length.out = 100), 'B' = seq(0, 1, length.out = 100))
pdata['Activation'] = f(pdata$A, pdata$B, acteqn)
p1 = ggplot(pdata, aes(A, B, fill = Activation)) +
  geom_raster() +
  scale_fill_distiller(palette = 'YlOrRd', direction = 1) +
  ggtitle('2 independent activators') +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )
pdata['Activation'] = f(pdata$A, pdata$B, inbeqn)
p2 = ggplot(pdata, aes(A, B, fill = Activation)) +
  geom_raster() +
  scale_fill_distiller(palette = 'YlOrRd', direction = 1) +
  ggtitle('2 independent inhibitors') +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )

multiplot(p1, p2, cols = 2)
```

#AND based interactions with the SAME act/inhib effect
Interactions covered here are those where both the regulators have the same
activation behaviour, that is either both are activators or both are inhibitors.
Both regulators work together therefore are independent.

The case of independent OR inhibitions (right figures) looks more like the
scenario where **A or B** inhibit C with independence.

```{r, echo=FALSE, message=FALSE, warning=FALSE}
igraph_options(plot.layout=layout_as_star)
par(mfrow = c(1, 2))
colmap = c('TRUE' = 'green', 'FALSE' = 'red')

#2 activators
gact = new('GraphGRN')
for (n in LETTERS[1:3]) {
  gact = addNode(gact, n)
}
gact = addEdge(gact, c('A', 'B'), 'C', edgetype = 'and', activation = c(T, T))

gdf = GraphGRN2df(gact)
ig = graph_from_data_frame(gdf$edges, directed = T, gdf$nodes)
E(ig)$color = c(colmap[as.character(E(ig)$type)[1:2]], 'darkgrey')
plot(ig, vertex.size = nsize, main = '2 dependent activators')

#2 inhibitors
ginb = new('GraphGRN')
for (n in LETTERS[1:3]) {
  ginb = addNode(ginb, n)
}
ginb = addEdge(ginb, c('A', 'B'), 'C', edgetype = 'and', activation = c(F, F))

gdf = GraphGRN2df(ginb)
ig = graph_from_data_frame(gdf$edges, directed = T, gdf$nodes)
E(ig)$color = c(colmap[as.character(E(ig)$type)[1:2]], 'darkgrey')
plot(ig, vertex.size = nsize, main = '2 dependent inhibitors')

#activation function plots
f = function(A, B, rateeqn) {
  C = 0
  eval(parse(text = rateeqn))
}

acteqn = generateRateEqn(getNode(gact, 'C'), gact)
inbeqn = generateRateEqn(getNode(ginb, 'C'), ginb)

#plot activation functions
pdata = expand.grid('A' = seq(0, 1, length.out = 100), 'B' = seq(0, 1, length.out = 100))
pdata['Activation'] = f(pdata$A, pdata$B, acteqn)
p1 = ggplot(pdata, aes(A, B, fill = Activation)) +
  geom_raster() +
  scale_fill_distiller(palette = 'YlOrRd', direction = 1) +
  ggtitle('2 dependent activators') +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )
pdata['Activation'] = f(pdata$A, pdata$B, inbeqn)
p2 = ggplot(pdata, aes(A, B, fill = Activation)) +
  geom_raster() +
  scale_fill_distiller(palette = 'YlOrRd', direction = 1) +
  ggtitle('2 dependent inhibitors') +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )

multiplot(p1, p2, cols = 2)
```

#Interactions with the DIFFERENT act/inhib effect
Interactions covered here are those where both the regulators have the DIFFERENT
activation behaviour, that is one is an activator while the other an inhibitor.

The case of dependent regulators (right figures) looks more like the
scenario where **A** activates **C** but **B** sequesters this regulation.

The case of independent regulators (left figures) looks more like the
scenario where **B** activates **C** but **A** dominantly activates **C**. I am
sure whether this kind of regulatory relations exist in biology.

```{r, echo=FALSE, message=FALSE, warning=FALSE}
igraph_options(plot.layout=layout_as_star)
par(mfrow = c(1, 2))
colmap = c('TRUE' = 'green', 'FALSE' = 'red')

#1 activator 1 inhibitor OR
gor = new('GraphGRN')
for (n in LETTERS[1:3]) {
  gor = addNode(gor, n)
}
gor = addEdge(gor, 'A', 'C', activation = T)
gor = addEdge(gor, 'B', 'C', activation = F)

gdf = GraphGRN2df(gor)
ig = graph_from_data_frame(gdf$edges, directed = T, gdf$nodes)
E(ig)$color = colmap[as.character(E(ig)$type)]
plot(ig, vertex.size = nsize, main = '1 act 1 inhib independent')

#1 activator 1 inhibitor AND
gand = new('GraphGRN')
for (n in LETTERS[1:3]) {
  gand = addNode(gand, n)
}
gand = addEdge(gand, c('A', 'B'), 'C', edgetype = 'and', activation = c(T, F))

gdf = GraphGRN2df(gand)
ig = graph_from_data_frame(gdf$edges, directed = T, gdf$nodes)
E(ig)$color = c(colmap[as.character(E(ig)$type)[1:2]], 'darkgrey')
plot(ig, vertex.size = nsize, main = '1 act 1 inhib dependent')

#activation function plots
f = function(A, B, rateeqn) {
  C = 0
  eval(parse(text = rateeqn))
}

oreqn = generateRateEqn(getNode(gor, 'C'), gor)
andeqn = generateRateEqn(getNode(gand, 'C'), gand)

#plot activation functions
pdata = expand.grid('A' = seq(0, 1, length.out = 100), 'B' = seq(0, 1, length.out = 100))
pdata['Activation'] = f(pdata$A, pdata$B, oreqn)
p1 = ggplot(pdata, aes(A, B, fill = Activation)) +
  geom_raster() +
  scale_fill_distiller(palette = 'YlOrRd', direction = 1) +
  ggtitle('1 act 1 inhib independent') +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )
pdata['Activation'] = f(pdata$A, pdata$B, andeqn)
p2 = ggplot(pdata, aes(A, B, fill = Activation)) +
  geom_raster() +
  scale_fill_distiller(palette = 'YlOrRd', direction = 1) +
  ggtitle('1 act 1 inhib dependent') +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )

multiplot(p1, p2, cols = 2)
```

#OR with different act/inhib effect further investigation

![Lac operon regulation](`r file.path(getwd(), 'lac_operon_repression.PNG')`){width=70%}

```{r, echo=FALSE, message=FALSE, warning=FALSE}
igraph_options(plot.layout=layout_as_star)
par(mfrow = c(1, 2))
colmap = c('TRUE' = 'green', 'FALSE' = 'red')

#1 activator 1 inhibitor OR
gor = new('GraphGRN')
for (n in c('LacRepressor', 'LacXYA', 'lactose')) {
  gor = addNode(gor, n)
}
gor = addEdge(gor, 'LacRepressor', 'LacXYA', activation = F)
gor = addEdge(gor, 'lactose', 'LacXYA', activation = T)

gdf = GraphGRN2df(gor)
ig = graph_from_data_frame(gdf$edges, directed = T, gdf$nodes)
E(ig)$color = colmap[as.character(E(ig)$type)]
plot(ig, vertex.size = nsize, main = '1 act 1 inhib independent')

#activation function plots
f = function(t, state, params) {
  with(as.list(c(state, params)), {
    list('LacXYA' = eval(parse(text = generateRateEqn(getNode(gor, 'LacXYA'), gor))))
  })
}

#plot LacXYA with varying amounts of lactose and fixed LacRepressor
s0 = c('LacXYA' = 0.5)
parms = c('LacRepressor' = 0.7, 'lactose' = 0)
times = seq(0, 5, by = 0.01)

res = foreach (i = seq(0, 1, by = 0.1), .packages = c('deSolve'), .combine = rbind) %do% {
  parms['lactose'] = i
  out = ode(y = s0, times = times, func = f, parms = parms)[ , 2]
  out = cbind('LacXYA' = out, 'lactose' = i, 't' = times)
  return(out)
}

pdata = as.data.frame(res)
colmap = colorRampPalette(c('yellow', 'orange', 'red'))(length(unique(res[,'lactose'])))
names(colmap) = unique(res[,'lactose'])
pdata$lactose = as.factor(pdata$lactose)

p1 = ggplot(pdata, aes(t, LacXYA, colour = lactose)) + geom_line(size = 1.2)+
  scale_colour_manual(values = colmap) +
  ggtitle('LacRepressor = 0.7 (fixed),\n lactose = [0,1]')

#plot LacXYA with varying amounts of LacRepressor and fixed lactose
s0 = c('LacXYA' = 0.5)
parms = c('LacRepressor' = 0, 'lactose' = 0.7)
times = seq(0, 5, by = 0.01)

res = foreach (i = seq(0, 1, by = 0.1), .packages = c('deSolve'), .combine = rbind) %do% {
  parms['LacRepressor'] = i
  out = ode(y = s0, times = times, func = f, parms = parms)[ , 2]
  out = cbind('LacXYA' = out, 'LacRepressor' = i, 't' = times)
  return(out)
}

pdata = as.data.frame(res)
colmap = colorRampPalette(c('yellow', 'orange', 'red'))(length(unique(res[,'LacRepressor'])))
names(colmap) = unique(res[,'LacRepressor'])
pdata$LacRepressor = as.factor(pdata$LacRepressor)

p2 = ggplot(pdata, aes(t, LacXYA, colour = LacRepressor)) + geom_line(size = 1.2)+
  scale_colour_manual(values = colmap) +
  ggtitle('LacRepressor = [0,1],\n lactose = 0.7 (fixed)')
multiplot(p1, p2, cols = 2)
```

#Generalization of complex regulatory behaviour
A represses C with the corepressor L. X inhibits this repression.

x-axis is L

y-axis is X
```{r, echo=FALSE, message=FALSE, warning=FALSE}
#1 activator 1 inhibitor OR
gor = new('GraphGRN')
for (n in c('A','C','L','X')) {
  gor = addNode(gor, n)
}
gor = addEdge(gor, 'A', 'C', activation = F)
gor = addEdge(gor, 'X', 'C', activation = T)
gor = addEdge(gor, 'L', 'C', activation = F)

#activation function
f = function(A, L, X) {
  C = 0
  eval(parse(text = generateRateEqn(getNode(gor, 'C'), gor)))
}

A = seq(0, 1, by = 0.01)
L = seq(0, 1, by = 0.01)
X = seq(0, 1, by = 0.01)

C = f(A, L, X)
hmdf = expand.grid('L' = seq(0, 1, by = 0.01), 'X' = seq(0, 1, by = 0.01))
hmdf$C = f(0.1, hmdf$L, hmdf$X)

#plotly slider
aval = list()
nsteps = 11
for (i in 1:nsteps){
  hmdf = expand.grid('L' = seq(0, 1, by = 0.01), 'X' = seq(0, 1, by = 0.01))
  A = i/nsteps
  aval[[i]] <-list(visible = FALSE,
                      name = round(A, digits = 2),
                      x = hmdf$L,
                      y = hmdf$X,
                      z = f(A, hmdf$L, hmdf$X))
  
  aval[i][[1]]$z[1] = 0
}
aval[1][[1]]$visible = TRUE

steps <- list()
p <- plot_ly(xaxis = list(title = 'L'), yaxis = list(title = 'X'))
for (i in 1:nsteps) {
  p = add_heatmap(p,x=aval[i][[1]]$x,  y=aval[i][[1]]$y, z=aval[i][[1]]$z, visible = aval[i][[1]]$visible, 
                 name = aval[i][[1]]$name, showlegend = FALSE)

  step <- list(args = list('visible', rep(FALSE, length(aval))),
               method = 'restyle')
  step$args[[2]][i] = TRUE  
  steps[[i]] = step 
}

p = p %>%
  layout(sliders = list(list(active = 1,
                             currentvalue = list(prefix = "A: "),
                             steps = steps)))
p
```

#Conditional dependence
```{r, message=FALSE, warning=FALSE, include=FALSE}
plotds <- function(d, ptitle, rteqn){
  plotd = as.data.frame(t(d))
  cors = cor(plotd)
  cors = round(cors, digits = 2)
  #score calculation
  classf = Mclust(d['B',], verbose = F)$classification
  #calc cors
  corlowB = round(cor(plotd[classf == 1, 1:2])[1, 2], digits = 2)
  corhighB = round(cor(plotd[classf == 2, 1:2])[1, 2], digits = 2)
  classf[classf == 1] = paste('low B (', corlowB, ')', sep = '')
  classf[classf == 2] = paste('high B (', corhighB, ')', sep = '')
  plotd$BClass = classf
  
  p1 = ggplot(plotd, aes(A, C, colour = B)) + geom_point() +
    scale_colour_distiller(palette = 'RdPu', direction = 1) +
    ggtitle(paste(ptitle, ' (cor = ', cors['A', 'C'], ')', sep = '')) +
    facet_wrap(~BClass) +
    theme_minimal() +
    theme(
      panel.grid.minor = element_blank(),
      axis.line = element_line(colour="black"),
      strip.background=element_rect(colour="#f0f0f0",fill="#f0f0f0")
    )
  
  #activation function plots
  f = function(A, B, rateeqn) {
    C = 0
    eval(parse(text = rateeqn))
  }
  
  #plot activation functions
  plotd = as.data.frame(t(d))
  pdata = expand.grid('A' = seq(0, 1, length.out = 100), 'B' = seq(0, 1, length.out = 100))
  pdata['Activation'] = f(pdata$A, pdata$B, rteqn)
  plotd$Activation = 1
  
  p2 = ggplot(pdata, aes(A, B, fill = Activation)) +
    geom_raster() +
    scale_fill_distiller(palette = 'YlOrRd', direction = 1) +
    ggtitle('1 act 1 inhib dependent') +
    theme_minimal() +
    theme(
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      legend.position = 'none'
    ) +
    geom_point(data = plotd, aes(A, B), colour = 'white', alpha = 0.2, size = 2)
  
  lyt = matrix(c(1,1,2),nrow = 1)
  multiplot(p1, p2, layout = lyt)
}

simseed = 360
nsamp = 100
```

Input models setting
```{r, echo=FALSE, message=FALSE, warning=FALSE}
g = new('GraphGRN')
for (n in c('B', 'A' ,'C')) {
  g = addNode(g, n)
}
g = addEdge(g, 'B', 'C', activation = T)
g = addEdge(g, 'A', 'C', activation = T)

sim = new('SimulationGRN', graph = g, seed = simseed)
inputModels = sim$inputModels

#model modification
inputModels$B$mean = c(0.2, 0.8)
inputModels$A$mean = 0.5
inputModels$A$sd = 0.15
inputModels$B$sd = c(0.05, 0.05)
sim$inputModels = inputModels

#plot densities of inputs
set.seed(simseed)
# extinputs = matrix(runif(nsamp * 2), ncol = 2)
# colnames(extinputs) = c('A', 'B')
extinputs = NULL
d = simulateDataset(sim, nsamp, extinputs)

plotd = as.data.frame(t(d))
cors = cor(plotd)
cors = round(cors, digits = 2)

histd = data.frame('Expr' = c(plotd$A, plotd$B), 'Gene' = rep(c('A', 'B'), each = nrow(plotd)))
ggplot(histd, aes(Expr, fill = Gene)) + geom_histogram(alpha = 0.7, position = 'identity') +
ggtitle(paste('Input data', ' (cor = ', cors['A', 'B'], ')', sep = '')) +
theme_minimal() +
theme(
  panel.grid.major = element_blank(),
  panel.grid.minor = element_blank()
  )

#2 activators OR
g = new('GraphGRN')
for (n in LETTERS[1:3]) {
  g = addNode(g, n)
}
g = addEdge(g, 'A', 'C', activation = T)
g = addEdge(g, 'B', 'C', activation = T)
sim = new('SimulationGRN', graph = g, seed = simseed)
sim$inputModels = inputModels
d = simulateDataset(sim, nsamp)
plotds(d, 'A OR B', generateRateEqn(getNode(g, 'C'), g))

#2 repressors OR
g = new('GraphGRN')
for (n in LETTERS[1:3]) {
  g = addNode(g, n)
}
g = addEdge(g, 'A', 'C', activation = F)
g = addEdge(g, 'B', 'C', activation = F)
sim = new('SimulationGRN', graph = g, seed = simseed)
sim$inputModels = inputModels
d = simulateDataset(sim, nsamp)
plotds(d, '!A OR !B', generateRateEqn(getNode(g, 'C'), g))

#1 repressor, 1 Activator OR
g = new('GraphGRN')
for (n in LETTERS[1:3]) {
  g = addNode(g, n)
}
g = addEdge(g, 'A', 'C', activation = F)
g = addEdge(g, 'B', 'C', activation = T)
sim = new('SimulationGRN', graph = g, seed = simseed)
sim$inputModels = inputModels
d = simulateDataset(sim, nsamp)
plotds(d, '!A OR B', generateRateEqn(getNode(g, 'C'), g))

#2 activators AND
g = new('GraphGRN')
for (n in LETTERS[1:3]) {
  g = addNode(g, n)
}
g = addEdge(g, c('A', 'B'), 'C', activation = c(T, T), edgetype = 'and')
sim = new('SimulationGRN', graph = g, seed = simseed)
sim$inputModels = inputModels
d = simulateDataset(sim, nsamp)
plotds(d, 'A AND B', generateRateEqn(getNode(g, 'C'), g))

#2 repressors AND
g = new('GraphGRN')
for (n in LETTERS[1:3]) {
  g = addNode(g, n)
}
g = addEdge(g, c('A', 'B'), 'C', activation = c(F, F), edgetype = 'and')
sim = new('SimulationGRN', graph = g, seed = simseed)
sim$inputModels = inputModels
d = simulateDataset(sim, nsamp)
plotds(d, '!A AND !B', generateRateEqn(getNode(g, 'C'), g))

#1 repressor, 1 Activator AND
g = new('GraphGRN')
for (n in LETTERS[1:3]) {
  g = addNode(g, n)
}
g = addEdge(g, c('A', 'B'), 'C', activation = c(T, F), edgetype = 'and')
sim = new('SimulationGRN', graph = g, seed = simseed)
sim$inputModels = inputModels
d = simulateDataset(sim, nsamp)
plotds(d, 'A AND !B', generateRateEqn(getNode(g, 'C'), g))
```












