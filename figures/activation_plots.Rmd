---
title: "Activation function characteristics"
output:
  html_notebook: 
    number_sections: yes
    toc: yes
    fig_caption: yes
---

Plots showing activation function behaviour of different biological interactions.


```{r, message=FALSE, warning=FALSE, include=FALSE}
source('../GraphGRN-methods.R')
source('../GraphGRN.R')
source('../SimulationGRN-methods.R')
source('../SimulationGRN.R')
library(igraph)
library(ggplot2)
library(grid)
library(ggraph)
library(deSolve)
library(foreach)

#activation function
fAct <- function(TF, EC50 = 0.5, n = 1.39) {
  B = (EC50 ^ n - 1) / (2 * EC50 ^ n - 1)
  K_n = (B - 1)
  act = B * TF ^ n / (K_n + TF ^ n)
  
  return(act)
}

#multiplot function
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
	
	# Make a list from the ... arguments and plotlist
	plots <- c(list(...), plotlist)
	
	numPlots = length(plots)
	
	# If layout is NULL, then use 'cols' to determine layout
	if (is.null(layout)) {
		# Make the panel
		# ncol: Number of columns of plots
		# nrow: Number of rows needed, calculated from # of cols
		layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
						 ncol = cols, nrow = ceiling(numPlots/cols))
	}
	
	if (numPlots==1) {
		print(plots[[1]])
		
	} else {
		# Set up the page
		grid.newpage()
		pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
		
		# Make each plot, in the correct location
		for (i in 1:numPlots) {
			# Get the i,j matrix positions of the regions that contain this subplot
			matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
			
			print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
											layout.pos.col = matchidx$col))
		}
	}
}

nsize = 40
```

#Activation functions
In the case where **A** activates or inhibits **B**, the rate equations are shown
below which are equal to the activation equations due to the parameter choices.

```{r, echo=FALSE, message=FALSE, warning=FALSE}
#activation function plots
f = function(A, rateeqn) {
  B = 0
  eval(parse(text = rateeqn))
}
A = seq(0, 1, length.out = 100)

#A->B
gact = new('GraphGRN')
gact = addNode(gact, 'A')
gact = addNode(gact, 'B')
gact = addEdge(gact, 'A', 'B', activation = T)
acteqn = generateRateEqn(getNode(gact, 'B'), gact)
B = f(A, acteqn)
plot(A, B, col = 3, type = 'l', main = 'A single activation function')

#A->B
ginb = new('GraphGRN')
ginb = addNode(ginb, 'A')
ginb = addNode(ginb, 'B')
ginb = addEdge(ginb, 'A', 'B', activation = F)
inbeqn = generateRateEqn(getNode(ginb, 'B'), ginb)
B = f(A, inbeqn)
par(new = T)
plot(A, B, col = 2, type = 'l')
par(new = F)
```


#OR based interactions with the SAME act/inhib effect
Interactions covered here are those where both the regulators have the same
activation behaviour, that is either both are activators or both are inhibitors.
Each regulator complements the other.

The case of independent OR inhibitions (right figures) looks more like the
scenario where **A and B** inhibit C with dependence.

```{r, echo=FALSE, message=FALSE, warning=FALSE}
igraph_options(plot.layout=layout_in_circle)
par(mfrow = c(1, 2))
colmap = c('TRUE' = 'green', 'FALSE' = 'red')

#2 activators
gact = new('GraphGRN')
for (n in LETTERS[1:3]) {
  gact = addNode(gact, n)
}
gact = addEdge(gact, 'A', 'C', activation = T)
gact = addEdge(gact, 'B', 'C', activation = T)

gdf = GraphGRN2df(gact)
ig = graph_from_data_frame(gdf$edges, directed = T, gdf$nodes)
E(ig)$color = colmap[as.character(E(ig)$type)]
plot(ig, vertex.size = nsize, main = '2 independent activators')

#2 inhibitors
ginb = new('GraphGRN')
for (n in LETTERS[1:3]) {
  ginb = addNode(ginb, n)
}
ginb = addEdge(ginb, 'A', 'C', activation = F)
ginb = addEdge(ginb, 'B', 'C', activation = F)

gdf = GraphGRN2df(ginb)
ig = graph_from_data_frame(gdf$edges, directed = T, gdf$nodes)
E(ig)$color = colmap[as.character(E(ig)$type)]
plot(ig, vertex.size = nsize, main = '2 independent inhibitors')

#activation function plots
f = function(A, B, rateeqn) {
  C = 0
  eval(parse(text = rateeqn))
}

acteqn = generateRateEqn(getNode(gact, 'C'), gact)
inbeqn = generateRateEqn(getNode(ginb, 'C'), ginb)

#plot activation functions
pdata = expand.grid('A' = seq(0, 1, length.out = 100), 'B' = seq(0, 1, length.out = 100))
pdata['Activation'] = f(pdata$A, pdata$B, acteqn)
p1 = ggplot(pdata, aes(A, B, fill = Activation)) +
  geom_raster() +
  scale_fill_distiller(palette = 'YlOrRd', direction = 1) +
  ggtitle('2 independent activators') +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )
pdata['Activation'] = f(pdata$A, pdata$B, inbeqn)
p2 = ggplot(pdata, aes(A, B, fill = Activation)) +
  geom_raster() +
  scale_fill_distiller(palette = 'YlOrRd', direction = 1) +
  ggtitle('2 independent inhibitors') +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )

multiplot(p1, p2, cols = 2)
```

#AND based interactions with the SAME act/inhib effect
Interactions covered here are those where both the regulators have the same
activation behaviour, that is either both are activators or both are inhibitors.
Both regulators work together therefore are independent.

The case of independent OR inhibitions (right figures) looks more like the
scenario where **A or B** inhibit C with independence.

```{r, echo=FALSE, message=FALSE, warning=FALSE}
igraph_options(plot.layout=layout_as_star)
par(mfrow = c(1, 2))
colmap = c('TRUE' = 'green', 'FALSE' = 'red')

#2 activators
gact = new('GraphGRN')
for (n in LETTERS[1:3]) {
  gact = addNode(gact, n)
}
gact = addEdge(gact, c('A', 'B'), 'C', edgetype = 'and', activation = c(T, T))

gdf = GraphGRN2df(gact)
ig = graph_from_data_frame(gdf$edges, directed = T, gdf$nodes)
E(ig)$color = c(colmap[as.character(E(ig)$type)[1:2]], 'darkgrey')
plot(ig, vertex.size = nsize, main = '2 dependent activators')

#2 inhibitors
ginb = new('GraphGRN')
for (n in LETTERS[1:3]) {
  ginb = addNode(ginb, n)
}
ginb = addEdge(ginb, c('A', 'B'), 'C', edgetype = 'and', activation = c(F, F))

gdf = GraphGRN2df(ginb)
ig = graph_from_data_frame(gdf$edges, directed = T, gdf$nodes)
E(ig)$color = c(colmap[as.character(E(ig)$type)[1:2]], 'darkgrey')
plot(ig, vertex.size = nsize, main = '2 dependent inhibitors')

#activation function plots
f = function(A, B, rateeqn) {
  C = 0
  eval(parse(text = rateeqn))
}

acteqn = generateRateEqn(getNode(gact, 'C'), gact)
inbeqn = generateRateEqn(getNode(ginb, 'C'), ginb)

#plot activation functions
pdata = expand.grid('A' = seq(0, 1, length.out = 100), 'B' = seq(0, 1, length.out = 100))
pdata['Activation'] = f(pdata$A, pdata$B, acteqn)
p1 = ggplot(pdata, aes(A, B, fill = Activation)) +
  geom_raster() +
  scale_fill_distiller(palette = 'YlOrRd', direction = 1) +
  ggtitle('2 dependent activators') +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )
pdata['Activation'] = f(pdata$A, pdata$B, inbeqn)
p2 = ggplot(pdata, aes(A, B, fill = Activation)) +
  geom_raster() +
  scale_fill_distiller(palette = 'YlOrRd', direction = 1) +
  ggtitle('2 dependent inhibitors') +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )

multiplot(p1, p2, cols = 2)
```

#Interactions with the DIFFERENT act/inhib effect
Interactions covered here are those where both the regulators have the DIFFERENT
activation behaviour, that is one is an activator while the other an inhibitor.

The case of dependent regulators (right figures) looks more like the
scenario where **A** activates **C** but **B** sequesters this regulation.

The case of independent regulators (left figures) looks more like the
scenario where **B** activates **C** but **A** dominantly activates **C**. I am
sure whether this kind of regulatory relations exist in biology.

```{r, echo=FALSE, message=FALSE, warning=FALSE}
igraph_options(plot.layout=layout_as_star)
par(mfrow = c(1, 2))
colmap = c('TRUE' = 'green', 'FALSE' = 'red')

#1 activator 1 inhibitor OR
gor = new('GraphGRN')
for (n in LETTERS[1:3]) {
  gor = addNode(gor, n)
}
gor = addEdge(gor, 'A', 'C', activation = T)
gor = addEdge(gor, 'B', 'C', activation = F)

gdf = GraphGRN2df(gor)
ig = graph_from_data_frame(gdf$edges, directed = T, gdf$nodes)
E(ig)$color = colmap[as.character(E(ig)$type)]
plot(ig, vertex.size = nsize, main = '1 act 1 inhib independent')

#1 activator 1 inhibitor AND
gand = new('GraphGRN')
for (n in LETTERS[1:3]) {
  gand = addNode(gand, n)
}
gand = addEdge(gand, c('A', 'B'), 'C', edgetype = 'and', activation = c(T, F))

gdf = GraphGRN2df(gand)
ig = graph_from_data_frame(gdf$edges, directed = T, gdf$nodes)
E(ig)$color = c(colmap[as.character(E(ig)$type)[1:2]], 'darkgrey')
plot(ig, vertex.size = nsize, main = '1 act 1 inhib dependent')

#activation function plots
f = function(A, B, rateeqn) {
  C = 0
  eval(parse(text = rateeqn))
}

oreqn = generateRateEqn(getNode(gor, 'C'), gor)
andeqn = generateRateEqn(getNode(gand, 'C'), gand)

#plot activation functions
pdata = expand.grid('A' = seq(0, 1, length.out = 100), 'B' = seq(0, 1, length.out = 100))
pdata['Activation'] = f(pdata$A, pdata$B, oreqn)
p1 = ggplot(pdata, aes(A, B, fill = Activation)) +
  geom_raster() +
  scale_fill_distiller(palette = 'YlOrRd', direction = 1) +
  ggtitle('1 act 1 inhib independent') +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )
pdata['Activation'] = f(pdata$A, pdata$B, andeqn)
p2 = ggplot(pdata, aes(A, B, fill = Activation)) +
  geom_raster() +
  scale_fill_distiller(palette = 'YlOrRd', direction = 1) +
  ggtitle('1 act 1 inhib dependent') +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )

multiplot(p1, p2, cols = 2)
```

#OR with different act/inhib effect further investigation

```{r, echo=FALSE, message=FALSE, warning=FALSE}
igraph_options(plot.layout=layout_as_star)
par(mfrow = c(1, 2))
colmap = c('TRUE' = 'green', 'FALSE' = 'red')

#1 activator 1 inhibitor OR
gor = new('GraphGRN')
for (n in LETTERS[1:3]) {
  gor = addNode(gor, n)
}
gor = addEdge(gor, 'A', 'C', activation = T)
gor = addEdge(gor, 'B', 'C', activation = F)

gdf = GraphGRN2df(gor)
ig = graph_from_data_frame(gdf$edges, directed = T, gdf$nodes)
E(ig)$color = colmap[as.character(E(ig)$type)]
plot(ig, vertex.size = nsize, main = '1 act 1 inhib independent')

#activation function plots
f = function(t, state, params) {
  with(as.list(c(state, params)), {
    list('C' = eval(parse(text = generateRateEqn(getNode(gor, 'C'), gor))))
  })
}

#plot C with varying amounts of B and fixed A
s0 = c('C' = 0.5)
parms = c('A' = 0.3, 'B' = 0)
times = seq(0, 5, by = 0.01)

res = foreach (i = seq(0, 1, by = 0.1), .packages = c('deSolve'), .combine = rbind) %do% {
  parms['B'] = i
  out = ode(y = s0, times = times, func = f, parms = parms)[ , 2]
  out = cbind('C' = out, 'B' = i, 't' = times)
  return(out)
}

pdata = as.data.frame(res)
colmap = colorRampPalette(c('yellow', 'orange', 'red'))(length(unique(res[,'B'])))
names(colmap) = unique(res[,'B'])
pdata$B = as.factor(pdata$B)

ggplot(pdata, aes(t, C, colour = B)) + geom_line(size = 1.2)+
  scale_colour_manual(values = colmap) +
  ggtitle('A = 0.3 (fixed), B=[0,1]')

```






